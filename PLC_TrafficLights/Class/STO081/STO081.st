//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "STO081"
	Revision           = "1.23"
	GUID               = "{0776DB14-DC62-4455-A5C0-8CCA38FD87AE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\sto.ico"
	SharedCommandTable = "true"
	Objectsize         = "(532,120)">
	<Channels>
		<Server Name="Safe_Output1" GUID="{2A500567-6CED-4120-83B9-DC1C15FC29FB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output2" GUID="{806DF77B-6CDD-4DF5-9C02-3A17A0ECB33B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output3" GUID="{F5343818-9257-47F3-81FE-91AB90795369}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output4" GUID="{930338CC-B276-4FC8-906B-6A72C0B669D1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output5" GUID="{D91F46D4-34EC-4F73-B5C7-11153C3B100D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output6" GUID="{0295DE00-EC78-4979-AB07-221A7F42E7DF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output7" GUID="{D6972616-806D-4CB5-86CD-8F7E1D5C8264}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="Safe_Output8" GUID="{7C3503CF-4C8B-4EB0-8A18-7DF73EA8A7CB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of output (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Output Low&#13;&#10; 1..Output High"/>
		<Server Name="SafeIOError" GUID="{91F2183C-38F2-4F37-BA91-585DC84BA215}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows which safe outputs are in error.&#13;&#10;The outputs are bitcoded.&#13;&#10;Bit0 = Output1&#13;&#10;Bit1 = Output2&#13;&#10;..."/>
		<Server Name="Unsafe_Output1" GUID="{F101EFA0-A45B-4FDB-ACB7-404557467740}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output2" GUID="{2BEC873C-FDAD-4856-8AE8-E4BA18DA9E5F}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output3" GUID="{6E7745E9-0FFA-4D36-9846-C8C384DD4B6D}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output4" GUID="{EE4387E7-434E-4098-AC6C-0EBA2EDCC78F}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output5" GUID="{27B373D8-3C38-4B67-974E-242353088FC6}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output6" GUID="{403A65E4-1D38-4316-8CE7-352D4A4305C5}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output7" GUID="{A337EF4C-57E5-421E-9462-2A5E46893924}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
		<Server Name="Unsafe_Output8" GUID="{AF277125-0D6A-4D4F-9CC4-AF806AC11854}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="State of output (write only; default value: 0)&#13;&#10;&#13;&#10;If safety is given (output would be 1), you can still switch to zero by writing 0 to this server"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="SeiChr"/>
		<Dokumentation Revision="1.23" Date="02.06.2021" Author="EisMic" Company="Sigmatek" Description="Added support for analog input modules and showing FW version of safety modules in baseclass."/>
		<Dokumentation Revision="1.22" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.21" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.20" Date="24.04.2018" Author="RamAnd" Company="Sigmatek" Description="Added server to show hardware version if this feature is supported by the safety firmware of the SCP."/>
		<Dokumentation Revision="1.19" Date="30.11.2017" Author="FurDom" Company="Sigmatek" Description="Added QuitComError server description to .lhd file"/>
		<Dokumentation Revision="1.18" Date="24.10.2016" Author="ZoePat" Company="Sigmatek" Description="Set the base class to visualized, so the embedded string object &quot;SerialNoStr&quot; can be used in the LSE."/>
		<Dokumentation Revision="1.17" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.16" Date="21.01.2016" Author="EisMic" Company="Sigmatek" Description="Outputs are now written in RtPostScan instead of RtPreScan to improve the reaction speed."/>
		<Dokumentation Revision="1.15" Date="16.04.2015" Author="EisMic" Company="Sigmatek" Description="Added support for graphical hardware editor."/>
		<Dokumentation Revision="1.14" Date="31.10.2014" Author="lanste" Company="Sigmatek" Description="Fixed error: Safe IO were displayed on wrong safety hardwareclass if the class is not required and not online.&#13;&#10;Fixed error: Safe IO were displayed on wrong safety hardwareclass if the hardware configuration did not match the project configuration.&#13;&#10;Set IOs to -2 if Class is not online."/>
		<Dokumentation Revision="1.13" Date="31.07.2014" Author="PieSte" Company="Sigmatek" Description="Added QuitComError server to quit errors on safety cpu."/>
		<Dokumentation Revision="1.12" Date="24.04.2014" Author="RamAnd" Company="Sigmatek" Description="Clear module info at the servers if a disconnect event occurs."/>
		<Dokumentation Revision="1.11" Date="28.03.2014" Author="EisMic" Company="Sigmatek" Description="Added server RetryCounteruC1 and RetryCounteruC2."/>
		<Dokumentation Revision="1.10" Date="22.01.2014" Author="RamAnd&#13;&#10;LanSte" Company="Sigmatek" Description="Added functionality to use module optional via define DEACTIVATED_LSL as Place value.&#13;&#10;Read Client Required and Place in Init SdiasSafetyBase"/>
		<Dokumentation Revision="1.0" Date="04.12.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="STO081">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{A6ADAC4F-CDFF-48E6-B0EF-B4A12008A2DC}"
				Class      = "SdiasSafetyBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="CallCommand"/>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FWVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="QuitComError"/>
					<Server Name="RetryCounteruC1"/>
					<Server Name="RetryCounteruC2"/>
					<Server Name="SafetyNumber"/>
					<Server Name="SerialNo"/>
					<Client Name="AnalogInputBytesNeeded"/>
					<Client Name="InputsNeeded" Value="0"/>
					<Client Name="OutputsNeeded" Value="8"/>
					<Client Name="Place"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasSafetyIn"/>
					<Client Name="SetDeviceID" Value="2#00010001"/>
					<Client Name="toStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(992,210),(820,210),"/>
			<Connection Source="_base.SdiasSafetyIn" Destination="this.SdiasSafetyIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(992,270),(820,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(992,390),(820,450),"/>
			<Connection Source="this.SafetyNumber" Destination="_base.SafetyNumber" Vertices="(992,450),(820,510),"/>
			<Connection Source="this.RetryCounteruC1" Destination="_base.RetryCounteruC1" Vertices="(992,510),(820,570),"/>
			<Connection Source="this.RetryCounteruC2" Destination="_base.RetryCounteruC2" Vertices="(992,570),(820,630),"/>
			<Connection Source="this.QuitComError" Destination="_base.QuitComError" Vertices="(992,630),(820,750),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(992,330),(820,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasSafetyBase

STO081 : CLASS
: SdiasSafetyBase
  //Servers:
	Safe_Output1 	: SvrCh_DINT;
	Unsafe_Output1 	: SvrCh_DINT;
	Safe_Output2 	: SvrCh_DINT;
	Unsafe_Output2 	: SvrCh_DINT;
	Safe_Output3 	: SvrCh_DINT;
	Unsafe_Output3 	: SvrCh_DINT;
	Safe_Output4 	: SvrCh_DINT;
	Unsafe_Output4 	: SvrCh_DINT;
	Safe_Output5 	: SvrCh_DINT;
	Unsafe_Output5 	: SvrCh_DINT;
	Safe_Output6 	: SvrCh_DINT;
	Unsafe_Output6 	: SvrCh_DINT;
	Safe_Output7 	: SvrCh_DINT;
	Unsafe_Output7 	: SvrCh_DINT;
	Safe_Output8 	: SvrCh_DINT;
	Unsafe_Output8 	: SvrCh_DINT;
	SafeIOError 	: SvrCh_BDINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Called when class state was set to _NoHardware &#13;&#10;No Implementation Overload in derived classes if needed " Name="SetClassStateError"/>
	FUNCTION VIRTUAL SetClassStateError;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output5::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output6::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output7::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Unsafe_Output8::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB STO081::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_STO081
1$UINT, 23$UINT, (SIZEOF(::STO081))$UINT, 
17$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1461101515), "STO081", //Class
TO_UDINT(2010300054), "SdiasSafetyBase", 1$UINT, 10$UINT, //Baseclass
//Servers:
(::STO081.Safe_Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2712786485), "Safe_Output1", 
(::STO081.Unsafe_Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4011610486), "Unsafe_Output1", 
(::STO081.Safe_Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(951617423), "Safe_Output2", 
(::STO081.Unsafe_Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1981087948), "Unsafe_Output2", 
(::STO081.Safe_Output3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1337964313), "Safe_Output3", 
(::STO081.Unsafe_Output3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(17969242), "Unsafe_Output3", 
(::STO081.Safe_Output4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3520799418), "Safe_Output4", 
(::STO081.Unsafe_Output4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2675353081), "Unsafe_Output4", 
(::STO081.Safe_Output5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2799440428), "Safe_Output5", 
(::STO081.Unsafe_Output5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3899757935), "Unsafe_Output5", 
(::STO081.Safe_Output6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1070941078), "Safe_Output6", 
(::STO081.Unsafe_Output6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1903740117), "Unsafe_Output6", 
(::STO081.Safe_Output7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1221751552), "Safe_Output7", 
(::STO081.Unsafe_Output7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(109048899), "Unsafe_Output7", 
(::STO081.Safe_Output8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3631050385), "Safe_Output8", 
(::STO081.Unsafe_Output8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2529225170), "Unsafe_Output8", 
(::STO081.SafeIOError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1952502172), "SafeIOError", 
//Clients:
END_FUNCTION


#define USER_CNT_STO081 2

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_STO081] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION STO081::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasSafetyBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasSafetyBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasSafetyBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_STO081;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetClassStateError();

#pragma warning (default : 74)
	SdiasSafetyBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasSafetyBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output1::Write() );
	IF Unsafe_Output1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output2::Write() );
	IF Unsafe_Output2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output3::Write() );
	IF Unsafe_Output3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output4::Write() );
	IF Unsafe_Output4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output5.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output5::Write() );
	IF Unsafe_Output5.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output6.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output6::Write() );
	IF Unsafe_Output6.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output7.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output7::Write() );
	IF Unsafe_Output7.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Unsafe_Output8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Unsafe_Output8::Write() );
	IF Unsafe_Output8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL STO081::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR 

  // 0 = inputs, 1 = outputs
  if EAX then

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10 then
      Safe_Output1 := to_dint(IOStates AND 2#1);

      // show error state of this IO
      SafeIOError.1 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output1 := -1;

      // show error state of this IO
      SafeIOError.1 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000 then
      Safe_Output2 := to_dint(IOStates AND 2#100) SHR 2;

      // show error state of this IO
      SafeIOError.2 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output2 := -1;

      // show error state of this IO
      SafeIOError.2 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000 then
      Safe_Output3 := to_dint(IOStates AND 2#10000) SHR 4;

      // show error state of this IO
      SafeIOError.3 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output3 := -1;

      // show error state of this IO
      SafeIOError.3 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000 then
      Safe_Output4 := to_dint(IOStates AND 2#1000000) SHR 6;

      // show error state of this IO
      SafeIOError.4 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output4 := -1;

      // show error state of this IO
      SafeIOError.4 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000000000 then
      Safe_Output5 := to_dint(IOStates AND 2#100000000) SHR 8;

      // show error state of this IO
      SafeIOError.5 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output5 := -1;

      // show error state of this IO
      SafeIOError.5 := TRUE;
    end_if;
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000000000 then
      Safe_Output6 := to_dint(IOStates AND 2#10000000000) SHR 10;

      // show error state of this IO
      SafeIOError.6 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output6 := -1;

      // show error state of this IO
      SafeIOError.6 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000000000 then
      Safe_Output7 := to_dint(IOStates AND 2#1000000000000) SHR 12;

      // show error state of this IO
      SafeIOError.7 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output7 := -1;

      // show error state of this IO
      SafeIOError.7 := TRUE;
    end_if;
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000000000000000 then
      Safe_Output8 := to_dint(IOStates AND 2#100000000000000) SHR 14;

      // show error state of this IO
      SafeIOError.8 := FALSE;
    else
      // otherwise, there's an error
      Safe_Output8 := -1;

      // show error state of this IO
      SafeIOError.8 := TRUE;
    end_if;
  end_if;
    
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output1 := 1;
    UnsafeOutputStates.1 := TRUE;
  else
    result := Unsafe_Output1 := 0;
    UnsafeOutputStates.1 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output2 := 1;
    UnsafeOutputStates.2 := TRUE;
  else
    result := Unsafe_Output2 := 0;
    UnsafeOutputStates.2 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output3 := 1;
    UnsafeOutputStates.3 := TRUE;
  else
    result := Unsafe_Output3 := 0;
    UnsafeOutputStates.3 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output4 := 1;
    UnsafeOutputStates.4 := TRUE;
  else
    result := Unsafe_Output4 := 0;
    UnsafeOutputStates.4 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output5::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output5 := 1;
    UnsafeOutputStates.5 := TRUE;
  else
    result := Unsafe_Output5 := 0;
    UnsafeOutputStates.5 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output6::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output6 := 1;
    UnsafeOutputStates.6 := TRUE;
  else
    result := Unsafe_Output6 := 0;
    UnsafeOutputStates.6 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output7::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output7 := 1;
    UnsafeOutputStates.7 := TRUE;
  else
    result := Unsafe_Output7 := 0;
    UnsafeOutputStates.7 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Unsafe_Output8::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input then
    result := Unsafe_Output8 := 1;
    UnsafeOutputStates.8 := TRUE;
  else
    result := Unsafe_Output8 := 0;
    UnsafeOutputStates.8 := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL STO081::Init

  SdiasSafetyBase::Init();
  
  if us_FirstScan = 1 then
    Unsafe_Output1 := Unsafe_Output1 <> 0;
    Unsafe_Output2 := Unsafe_Output2 <> 0;
    Unsafe_Output3 := Unsafe_Output3 <> 0;
    Unsafe_Output4 := Unsafe_Output4 <> 0;
    Unsafe_Output5 := Unsafe_Output5 <> 0;
    Unsafe_Output6 := Unsafe_Output6 <> 0;
    Unsafe_Output7 := Unsafe_Output7 <> 0;
    Unsafe_Output8 := Unsafe_Output8 <> 0;
    
    UnsafeOutputStates.1 := to_bool(Unsafe_Output1);
    UnsafeOutputStates.2 := to_bool(Unsafe_Output2);
    UnsafeOutputStates.3 := to_bool(Unsafe_Output3);
    UnsafeOutputStates.4 := to_bool(Unsafe_Output4);
    UnsafeOutputStates.5 := to_bool(Unsafe_Output5);
    UnsafeOutputStates.6 := to_bool(Unsafe_Output6);
    UnsafeOutputStates.7 := to_bool(Unsafe_Output7);
    UnsafeOutputStates.8 := to_bool(Unsafe_Output8);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL STO081::SetClassStateError
  VAR
    i : UDINT;
    pServer : ^DINT;
  END_VAR
  
  pServer := #Safe_Output1;
  
  for i := 0 to 7 do
    pServer^ := SDIAS_SAFETY_INVALID_IO_NOHW;
    pServer += sizeof(SvrCh) * 2;
  end_for;
END_FUNCTION
